from web3 import Web3, exceptions
from eth_account import Account
from colorama import init, Fore
import time

# Inisialisasi colorama
init(autoreset=True)

# Inisialisasi koneksi ke RPC
rpc_url = 'https://rpc-testnet.unit0.dev'
chain_id = 88817
w3 = Web3(Web3.HTTPProvider(rpc_url))

# Pastikan koneksi berhasil
if not w3.isConnected():
    print(Fore.RED + "Koneksi ke RPC gagal")
    exit()

# Fungsi untuk membaca private key dari file
def read_private_key(filename='private_key.txt'):
    try:
        with open(filename, 'r') as file:
            private_key = file.read().strip()
        return private_key
    except FileNotFoundError:
        print(Fore.RED + f"File {filename} tidak ditemukan.")
        exit()

# Fungsi untuk mengirim token
def send_tokens(sender_private_key, to_address, amount, gas_price, gas_limit):
    sender_address = Account.from_key(sender_private_key).address
    amount_wei = w3.toWei(amount, 'ether')

    # Periksa saldo akun pengirim
    balance = w3.eth.getBalance(sender_address)
    total_cost = amount_wei + (gas_price * gas_limit)
    if balance < total_cost:
        raise ValueError(f'Saldo tidak mencukupi: saldo {balance}, biaya total {total_cost}')

    nonce = get_nonce_with_retry(sender_address)
    
    tx = {
        'nonce': nonce,
        'to': to_address,
        'value': amount_wei,
        'gas': gas_limit,
        'gasPrice': int(gas_price),
        'chainId': chain_id,
    }

    signed_tx = w3.eth.account.signTransaction(tx, sender_private_key)
    
    try:
        tx_hash = w3.eth.sendRawTransaction(signed_tx.rawTransaction)
        print(Fore.GREEN + f"Transaksi berhasil, tx hash: {tx_hash.hex()}")
        return tx_hash
    except exceptions.TransactionNotFound as e:
        print(Fore.RED + "Transaksi tidak ditemukan:", e)
    except exceptions.ValidationError as e:
        print(Fore.RED + "Kesalahan validasi:", e)
    except exceptions.TransactionError as e:
        print(Fore.RED + "Kesalahan transaksi:", e)
    except Exception as e:
        if 'message' in e.args[0] and e.args[0]['message'] == 'Known transaction':
            print(Fore.YELLOW + "Transaksi sudah diketahui oleh jaringan, kemungkinan nonce yang sama digunakan.")
        elif 'message' in e.args[0] and e.args[0]['message'] == 'Replacement transaction underpriced':
            print(Fore.YELLOW + "Transaksi pengganti terlalu murah, meningkatkan gas price dan mencoba lagi.")
            return send_tokens(sender_private_key, to_address, amount, gas_price * 1.1, gas_limit)
        else:
            print(Fore.RED + "Terjadi kesalahan:", e)
    return None

# Fungsi untuk mendapatkan nonce dengan penanganan kesalahan
def get_nonce_with_retry(address, retries=5, delay=5):
    for i in range(retries):
        try:
            nonce = w3.eth.getTransactionCount(address, 'pending')
            return nonce
        except exceptions.RequestsError as e:
            print(Fore.RED + "Kesalahan saat mengambil nonce:", e)
            time.sleep(delay)
        except exceptions.TimeExhausted as e:
            print(Fore.RED + "Waktu permintaan habis:", e)
            time.sleep(delay)
        except exceptions.BadFunctionCallOutput as e:
            print(Fore.RED + "Keluaran panggilan fungsi buruk:", e)
            time.sleep(delay)
    raise ValueError("Gagal mendapatkan nonce setelah beberapa kali percobaan")

# Fungsi utama
def main():
    sender_private_key = read_private_key()
    to_address = '0xYourRecipientAddress'  # Ganti dengan alamat tujuan
    amount = 0.01  # Ganti dengan jumlah yang ingin dikirim
    gas_price = 10**11  # Gas price dalam wei, setara dengan 0.0000001 UNIT0
    gas_limit = 21000

    try:
        tx_hash = send_tokens(sender_private_key, to_address, amount, gas_price, gas_limit)
        if tx_hash:
            print(Fore.GREEN + f"Transaksi berhasil, tx hash: {tx_hash.hex()}")
    except ValueError as e:
        print(Fore.RED + str(e))
    except Exception as e:
        print(Fore.RED + "Terjadi kesalahan:", str(e))

if __name__ == "__main__":
    main()
